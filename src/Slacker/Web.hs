module Slacker.Web
  ( -- * Message formatting
    MessageContent(..)
  , blocks_
  , blocks
  , blocksJSON
  , textMessage
    -- * Response URL
  , MessagePayload(..)
  , respondMessage
  , response
  , textResponse
  , ephemeral
    -- * chat.postMessage
  , PostMessagePayload(..)
  , postMessage
  , toChannel
  , toThread
    -- * General POST helpers
  , makeSlackPostJSON
  , makeSlackPostJSONNoBody
  , module Export
  ) where

import           Control.Monad (void)
import           Control.Monad.IO.Unlift (MonadIO, liftIO)
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Types as Aeson
import           Data.Maybe (catMaybes)
import           Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import           Data.WorldPeace
import           GHC.Exts (IsString(..))
import           GHC.Generics (Generic)
import           Lens.Micro ((^?), (^.))
import           Lens.Micro.Aeson (_Bool, _String, key)
import qualified Network.HTTP.Client as HTTP
import qualified Network.HTTP.Simple as HTTP
import           UnliftIO.Exception

import           Slacker.Blocks
import           Slacker.Config (SlackConfig(..))
import           Slacker.Web.Files as Export

data MessagePayload
  = MessagePayload
  { mpEphemeral :: !Bool
  , mpContent   :: !MessageContent
  }
  deriving stock (Generic)

instance Aeson.ToJSON MessagePayload where
  toJSON MessagePayload{..}
    = Aeson.object
    $ catMaybes
    [ if mpEphemeral
        then Just ("response_type" Aeson..= Aeson.String "ephemeral")
        else Nothing
    ] ++ messageContentFields mpContent

instance IsString MessagePayload where
  fromString = textResponse . fromString

-- | Turn formatted content into a response payload.
response :: MessageContent -> MessagePayload
response = MessagePayload False

textResponse :: Text -> MessagePayload
textResponse = response . textMessage

-- | Turn formatted content into an ephemeral response.
-- https://api.slack.com/interactivity/handling#publishing_ephemeral_response
ephemeral :: MessageContent -> MessagePayload
ephemeral = MessagePayload True

data PostMessagePayload
  = PostMessagePayload
  { pmpChannel  :: !Text
  , pmpThreadTs :: !(Maybe Text)
  , pmpContent  :: !MessageContent
  }
  deriving stock (Generic)

instance Aeson.ToJSON PostMessagePayload where
  toJSON PostMessagePayload{..}
    = Aeson.object
    $ catMaybes
    [ Just $ "channel" Aeson..= pmpChannel
    , fmap ("thread_ts" Aeson..=) pmpThreadTs
    ] ++ messageContentFields pmpContent

-- | Build a postMessage payload for a channel message.
toChannel :: Text -> MessageContent -> PostMessagePayload
toChannel cid = PostMessagePayload cid Nothing

-- | Build a postMessage payload for a thread reply.
toThread :: Text -> Text -> MessageContent -> PostMessagePayload
toThread cid ts = PostMessagePayload cid (Just ts)

data MessageContent
  = MessageBlocks !(Maybe Text) ![OpenUnion AllBlocks]
  -- ^ Blocks with optional text fallback.
  | MessageText !Text
  -- ^ Text only.
  | MessageBlocksJSON !Aeson.Value
  -- ^ An escape hatch. Useful if you want to use something like `aesonQQ` to write
  -- literal JSON, like that generated by the Block Kit Builder:
  -- https://app.slack.com/block-kit-builder/

instance IsString MessageContent where
  fromString = textMessage . fromString

messageContentFields :: MessageContent -> [Aeson.Pair]
messageContentFields mc =
  case mc of
    MessageBlocks mText bs -> catMaybes
      [ Just $ "blocks" Aeson..= bs
      , fmap ("text" Aeson..=) mText
      ]
    MessageText txt ->
      [ "text" Aeson..= txt ]
    MessageBlocksJSON val ->
      [ "blocks" Aeson..= val ]

-- | Construct a message as blocks with fallback text
blocks :: Text -> Blocks i () -> MessageContent
blocks txt bs = MessageBlocks (Just txt) (blocksToUnion bs [])

-- | Construct a message as blocks only
blocks_ :: Blocks i () -> MessageContent
blocks_ bs = MessageBlocks Nothing (blocksToUnion bs [])

-- | An escape hatch if you want to use something like `aesonQQ` to write
-- literal JSON, like that generated by the Block Kit Builder:
-- https://app.slack.com/block-kit-builder/
blocksJSON :: Aeson.Value -> MessageContent
blocksJSON = MessageBlocksJSON

-- | Construct a text message
textMessage :: Text -> MessageContent
textMessage = MessageText

-- | Respond to a user via an action's response URL.
-- https://api.slack.com/interactivity/handling#message_responses
respondMessage
  :: MonadIO m
  => Text
  -- ^ Response URL from Slack.
  -> MessagePayload
  -> m ()
respondMessage url body = do
  req <- liftIO $ HTTP.parseRequest $ "POST " <> T.unpack url
  void . HTTP.httpLBS . HTTP.setRequestBodyJSON body . HTTP.setRequestCheckStatus $ req

-- | Use the `chat.postMessage` method to send a message to a particular channel.
postMessage
  :: MonadIO m
  => SlackConfig
  -> PostMessagePayload
  -> m ()
postMessage cfg payload =
  void $
    makeSlackPostJSON
      (slackApiToken cfg)
      "chat.postMessage"
      payload

makeSlackPostJSON
  :: (MonadIO m, Aeson.ToJSON val)
  => Text
  -> Text
  -> val
  -> m Aeson.Value
makeSlackPostJSON token method body =
  makeSlackPostJSONImpl token method (Just body)

makeSlackPostJSONNoBody
  :: (MonadIO m)
  => Text
  -> Text
  -> m Aeson.Value
makeSlackPostJSONNoBody token method =
  makeSlackPostJSONImpl token method (Nothing @(Maybe ()))

makeSlackPostJSONImpl
  :: (MonadIO m, Aeson.ToJSON val)
  => Text
  -> Text
  -> Maybe val
  -> m Aeson.Value
makeSlackPostJSONImpl auth method mBody = do
  req <- liftIO $ HTTP.parseRequest $ "POST " <> "https://slack.com/api/" <> T.unpack method
  resp
    <- fmap HTTP.responseBody
     . HTTP.httpJSON
     . HTTP.addRequestHeader "Authorization" ("Bearer " <> T.encodeUtf8 auth)
     . maybe id HTTP.setRequestBodyJSON mBody
     $ req
  case resp ^? key "ok"  . _Bool of
    Just True  -> pure resp
    Just False -> throwIO $ userError $ T.unpack $ resp ^. key "error" . _String
    Nothing    -> throwIO $ userError "Couldn't parse key 'ok' from response"
