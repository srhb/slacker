module Slacker.Web
  ( -- * Message formatting
    MessageContent(..)
  , blocks_
  , blocks
  , blocksJSON
  , textMessage
    -- * Interaction Response
  , ResponsePayload(..)
  , respondMessage
  , response
  , textResponse
  , ephemeral
    -- * chat.postMessage
  , PostMessagePayload(..)
  , postMessage
  , toChannel
  , toThread
    -- * reactions.add
  , Channel
  , Emoji
  , Timestamp
  , addReaction
    -- * JSON POST helpers
  , ApiToken
  , Method
  , makeSlackPostJSON
  , makeSlackPostJSONNoBody
  , module Export
  ) where

import           Control.Monad (void)
import           Control.Monad.IO.Unlift (MonadIO, liftIO)
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Types as Aeson
import           Data.Maybe (catMaybes)
import           Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import           Data.WorldPeace
import           GHC.Exts (IsString(..))
import           GHC.Generics (Generic)
import           Lens.Micro ((^?), (^.))
import           Lens.Micro.Aeson (_Bool, _String, key)
import qualified Network.HTTP.Client as HTTP
import qualified Network.HTTP.Simple as HTTP
import           UnliftIO.Exception

import           Slacker.Blocks
import           Slacker.Config (SlackConfig(..))
import           Slacker.Web.Files as Export

data ResponsePayload
  = ResponsePayload
  { mpEphemeral :: !Bool
  , mpContent   :: !MessageContent
  }
  deriving stock (Generic)

instance Aeson.ToJSON ResponsePayload where
  toJSON ResponsePayload{..}
    = Aeson.object
    $ catMaybes
    [ if mpEphemeral
        then Just ("response_type" Aeson..= Aeson.String "ephemeral")
        else Nothing
    ] ++ messageContentFields mpContent

instance IsString ResponsePayload where
  fromString = textResponse . fromString

-- | Turn formatted content into a response payload
response :: MessageContent -> ResponsePayload
response = ResponsePayload False

-- | Helper to convert text into an interaction text response.
textResponse :: Text -> ResponsePayload
textResponse = response . textMessage

-- | Turn formatted content into an ephemeral response.
-- https://api.slack.com/interactivity/handling#publishing_ephemeral_response
ephemeral :: MessageContent -> ResponsePayload
ephemeral = ResponsePayload True

data PostMessagePayload
  = PostMessagePayload
  { pmpChannel  :: !Text
  , pmpThreadTs :: !(Maybe Text)
  , pmpContent  :: !MessageContent
  }
  deriving stock (Generic)

instance Aeson.ToJSON PostMessagePayload where
  toJSON PostMessagePayload{..}
    = Aeson.object
    $ catMaybes
    [ Just $ "channel" Aeson..= pmpChannel
    , fmap ("thread_ts" Aeson..=) pmpThreadTs
    ] ++ messageContentFields pmpContent

-- | Build a postMessage payload for a channel message.
toChannel :: Text -> MessageContent -> PostMessagePayload
toChannel cid = PostMessagePayload cid Nothing

-- | Build a postMessage payload for a thread reply.
toThread :: Text -> Text -> MessageContent -> PostMessagePayload
toThread cid ts = PostMessagePayload cid (Just ts)

data MessageContent
  = MessageBlocks !(Maybe Text) ![OpenUnion AllBlocks]
  -- ^ Blocks with optional text fallback.
  | MessageText !Text
  -- ^ Text only.
  | MessageBlocksJSON !Aeson.Value
  -- ^ An escape hatch. Useful if you want to use something like `aesonQQ` to write
  -- literal JSON, like that generated by the Block Kit Builder:
  -- https://app.slack.com/block-kit-builder/

instance IsString MessageContent where
  fromString = textMessage . fromString

messageContentFields :: MessageContent -> [Aeson.Pair]
messageContentFields mc =
  case mc of
    MessageBlocks mText bs -> catMaybes
      [ Just $ "blocks" Aeson..= bs
      , fmap ("text" Aeson..=) mText
      ]
    MessageText txt ->
      [ "text" Aeson..= txt ]
    MessageBlocksJSON val ->
      [ "blocks" Aeson..= val ]

-- | Construct a message as blocks with fallback text
blocks :: Text -> Blocks i () -> MessageContent
blocks txt bs = MessageBlocks (Just txt) (blocksToUnion bs [])

-- | Construct a message as blocks only
blocks_ :: Blocks i () -> MessageContent
blocks_ bs = MessageBlocks Nothing (blocksToUnion bs [])

-- | An escape hatch if you want to use something like `aesonQQ` to write
-- literal JSON, like that generated by the Block Kit Builder:
-- https://app.slack.com/block-kit-builder/
blocksJSON :: Aeson.Value -> MessageContent
blocksJSON = MessageBlocksJSON

-- | Construct message content from text.
textMessage :: Text -> MessageContent
textMessage = MessageText

-- | Respond to an interaction via a response URL.
-- Slack requires you to respond to an interaction within 30 minutes.
-- https://api.slack.com/interactivity/handling#message_responses
respondMessage
  :: MonadIO m
  => Text
  -- ^ Response URL from Slack.
  -> ResponsePayload
  -> m ()
respondMessage url body = do
  req <- liftIO $ HTTP.parseRequest $ "POST " <> T.unpack url
  void . HTTP.httpLBS . HTTP.setRequestBodyJSON body . HTTP.setRequestCheckStatus $ req

-- | Use the chat.postMessage method to send a message to a particular channel.
-- Requires bot scope of chat:write.
postMessage
  :: MonadIO m
  => SlackConfig
  -> PostMessagePayload
  -> m ()
postMessage cfg payload =
  void $
    makeSlackPostJSON
      (slackApiToken cfg)
      "chat.postMessage"
      payload

data ReactionsAddPayload
  = ReactionsAddPayload
  { raChannel   :: Channel
  , raName      :: Emoji
  , raTimestamp :: Timestamp
  } deriving (Eq, Show, Generic)

instance Aeson.ToJSON ReactionsAddPayload where
  toJSON = Aeson.genericToJSON Aeson.defaultOptions
    { Aeson.omitNothingFields = True
    , Aeson.fieldLabelModifier = Aeson.camelTo2 '_' . drop 2
    }

type Channel   = Text
type Emoji     = Text
type Timestamp = Text

-- | Use the reactions.add method to react to a particular timestamp in a channel.
-- Be careful as this will throw an exception if you add a reaction that already exists.
-- Requires bot scope of reactions:write.
addReaction
  :: MonadIO m
  => SlackConfig
  -> Channel
  -> Timestamp
  -> Emoji
  -> m ()
addReaction cfg cid ts emo =
  void $
    makeSlackPostJSON
      (slackApiToken cfg)
      "reactions.add"
      (ReactionsAddPayload cid emo ts)

type ApiToken = Text
type Method   = Text

makeSlackPostJSON
  :: (MonadIO m, Aeson.ToJSON val)
  => ApiToken
  -> Method
  -> val
  -> m Aeson.Value
makeSlackPostJSON token method body =
  makeSlackPostJSONImpl token method (Just body)

makeSlackPostJSONNoBody
  :: (MonadIO m)
  => ApiToken
  -> Method
  -> m Aeson.Value
makeSlackPostJSONNoBody token method =
  makeSlackPostJSONImpl token method (Nothing @(Maybe ()))

makeSlackPostJSONImpl
  :: (MonadIO m, Aeson.ToJSON val)
  => ApiToken
  -> Method
  -> Maybe val
  -> m Aeson.Value
makeSlackPostJSONImpl auth method mBody = do
  req <- liftIO $ HTTP.parseRequest $ "POST " <> "https://slack.com/api/" <> T.unpack method
  resp
    <- fmap HTTP.responseBody
     . HTTP.httpJSON
     . HTTP.addRequestHeader "Authorization" ("Bearer " <> T.encodeUtf8 auth)
     . maybe id HTTP.setRequestBodyJSON mBody
     $ req
  case resp ^? key "ok"  . _Bool of
    Just True  -> pure resp
    Just False -> throwIO $ userError $ T.unpack $ resp ^. key "error" . _String
    Nothing    -> throwIO $ userError "Couldn't parse key 'ok' from response"
